{"version":3,"sources":["utils/tuple.ts","utils/getter.ts","utils/effect.ts","modules/canvas/index.ts","modules/emitter/index.ts","utils/string.ts","apps/circles/index.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["tuple","ts","getter","key","o","getter2","k1","k2","dot","fromIO","io","T","sync","rndColor","alpha","Do","effect","bind","Rnd","pure","pipe","IO","a","return","r","g","b","takeUntil","until","s","stream","wrappedUntil","S","as","type","encaseEffect","wrappedStream","map","value","mergeAll","takeWhile","wrapped","filter","takeUntil_","uri","group","instructions","clear","accessM","_","clearRect","accessCanvas","canvas","canvasPropIfNot","prop","el","accessCanvasProp","canvasWidthIfNot","canvasHeightIfNot","makeClearRectLive","ctx","x","y","width","height","doL","args","parseInstruction","instruction","parseInstructions","arc","lineTo","moveTo","save","restore","beginPath","closePath","fill","fillStyle","lineWidth","stroke","strokeStyle","A","sequence","accessContext","f","subscribe","fromSource","M","managed","chain","bracket","su","queueUtils","next","ops","hasCB","unsubscribe","addEventListener","fromEvent","fn","_tag","emitter","charCodeAt","at","str","mapMouseEventToCoord","e","offsetX","offsetY","makeOnClick","makeEffect","Canvas","canvasEl","Emitter","flow","drawCirclesOnClick","sa","ea","zip","Math","PI","list","marker","drawMarkerOnClick","takeOne","take","collectArray","drawPolygon","currentState","restoreCanvas","ref","makeRef","coords","instructionGroup","O","polygonRef","coord","set","constant","race","event","update","get","eventType","do","h","t","polygonCoordinates2Effect","polygonInstructions","length","done","repeat","makeWaitForMenuChoice","menuCodes","includes","String","fromCharCode","waitForMainMenuChoice","waitForToolMenuChoice","makeDoUntilMenuChoice","parZip","main","stateRef","forever","state","bindL","mainMenuChoice","option","suboptions","additionalInstructions","console","log","current","identity","useCircles","canvasRef","React","getContext","provideS","rootEl","document","cb","removeEventListener","radius","startAngle","endAngle","anticlockwise","abs","color","provideConsole","run","useCanvas","useRef","useState","setSize","useEffect","setTimeout","parentElement","getBoundingClientRect","App","Circles","id","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.05e1134e.chunk.js","sourcesContent":["export const tuple = <T extends any[]>(...ts: T) => ts;","/**\r\n * @packageDocumentation\r\n * @module utils\r\n */\r\n\r\n/**\r\n * Type that describes a function that returns\r\n * the value of on object's property given\r\n *\r\n * @typeparam TKey The key or property name the function should read and return from a given object.\r\n * @typeparam TValue The value type\r\n * @typeparam TObject The object type\r\n */\r\nexport type Getter<TKey extends string> = <\r\n  TValue,\r\n  TObject extends {\r\n    [P in TKey]: TValue;\r\n  }\r\n>(\r\n  o: TObject\r\n) => TObject[TKey];\r\n\r\n/**\r\n *\r\n * @param key\r\n */\r\nexport const getter = <K extends string>(key: K): Getter<K> => <\r\n  T,\r\n  O extends { [P in K]: T }\r\n>(\r\n  o: O\r\n) => o[key];\r\n\r\nexport const getter2 = <K1 extends string, K2 extends string>(\r\n  k1: K1,\r\n  k2: K2\r\n) => <T, O extends { [P in K1]: { [R in K2]: T } }>(o: O) => o[k1][k2];\r\n\r\nexport const dot = getter;\r\nexport const dot2 = getter2;\r\nexport const pluck = getter;\r\nexport const pluck2 = getter2;\r\n\r\nexport const getEventCurrentTargetValue = dot2(\"detail\", \"value\");\r\n","import * as IO from \"fp-ts/lib/IO\";\r\nimport * as Rnd from \"fp-ts/lib/Random\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\nimport { effect as T, stream as S } from \"@matechs/effect\";\r\n\r\nexport const fromIO = <T>(io: IO.IO<T>) => {\r\n  return T.sync(() => io());\r\n};\r\n\r\nexport const rndColor = (alpha?: number) =>\r\n  Do(T.effect)\r\n    .bind(\"r\", fromIO(Rnd.randomInt(0, 255)))\r\n    .bind(\"g\", fromIO(Rnd.randomInt(0, 255)))\r\n    .bind(\"b\", fromIO(Rnd.randomInt(0, 255)))\r\n    .bind(\r\n      \"a\",\r\n      alpha != null\r\n        ? T.pure(alpha)\r\n        : fromIO(\r\n            pipe(\r\n              Rnd.randomInt(0, 10),\r\n              IO.map((a) => a / 10)\r\n            )\r\n          )\r\n    )\r\n    .return(({ r, g, b, a }) => `rgba(${r}, ${g}, ${b}, ${a})`);\r\n\r\n/**\r\n * Take elements from a stream until a given effect resolves.\r\n *\r\n * @param until The effect that will terminate the stream\r\n * @param stream The stream\r\n */\r\nfunction takeUntil_<R1, E1, R2, E2, A>(\r\n  stream: S.Stream<R1, E1, A>,\r\n  until: T.Effect<R2, E2, any>\r\n) {\r\n  type Wrapped = { type: \"until\" } | { type: \"stream\"; value: A };\r\n\r\n  const wrappedUntil = S.as<Wrapped>({ type: \"until\" })(S.encaseEffect(until));\r\n\r\n  const wrappedStream = pipe(\r\n    stream,\r\n    S.map((value): Wrapped => ({ type: \"stream\", value }))\r\n  );\r\n\r\n  return pipe(\r\n    S.mergeAll([wrappedUntil as any, wrappedStream as any] as S.Stream<\r\n      R1 & R2,\r\n      E1 | E2,\r\n      Wrapped\r\n    >[]),\r\n    S.takeWhile((wrapped) => wrapped.type === \"stream\"),\r\n    S.filter(\r\n      (wrapped): wrapped is Extract<Wrapped, { type: \"stream\" }> =>\r\n        wrapped.type === \"stream\"\r\n    ),\r\n    S.map((wrapped) => (wrapped as Extract<Wrapped, { type: \"stream\" }>).value)\r\n  );\r\n}\r\n\r\nexport function takeUntil<R2, E2>(until: T.Effect<R2, E2, any>) {\r\n  return function <R1, E1, A>(s: S.Stream<R1, E1, A>) {\r\n    return takeUntil_(s, until);\r\n  };\r\n}\r\n","import { effect as T } from \"@matechs/effect\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport * as Rnd from \"fp-ts/lib/Random\";\r\nimport * as A from \"fp-ts/lib/Array\";\r\n\r\nimport { fromIO, rndColor } from \"../../utils/effect\";\r\nimport { tuple } from \"../../utils/tuple\";\r\n\r\nexport const uri = \"@uri/canvas\";\r\n\r\ninterface Flavoring<FlavorT> {\r\n  _type?: FlavorT;\r\n}\r\n\r\nexport type Flavor<T, FlavorT> = T & Flavoring<FlavorT>;\r\n\r\ntype Radian = Flavor<number, \"radius\">;\r\n\r\ntype Arc = {\r\n  type: \"@instruction/arc\";\r\n  args: [number, number, number, number, number, boolean];\r\n};\r\n\r\ntype ClearRect = {\r\n  type: \"@instruction/clearRect\";\r\n  args: [number, number, number, number];\r\n};\r\n\r\ntype LineTo = {\r\n  type: \"@instruction/lineTo\";\r\n  args: [number, number];\r\n};\r\n\r\ntype MoveTo = {\r\n  type: \"@instruction/moveTo\";\r\n  args: [number, number];\r\n};\r\n\r\ntype BeginPath = { type: \"@instruction/beginPath\" };\r\ntype ClosePath = { type: \"@instruction/closePath\" };\r\ntype Stroke = { type: \"@instruction/stroke\" };\r\ntype Fill = { type: \"@instruction/fill\" };\r\ntype Save = { type: \"@instruction/save\" };\r\ntype Restore = { type: \"@instruction/restore\" };\r\ntype LineWidth = { type: \"@instruction/lineWidth\"; args: [number] };\r\ntype StrokeStyle = { type: \"@instruction/strokeStyle\"; args: [string] };\r\ntype FillStyle = { type: \"@instruction/fillStyle\"; args: [string] };\r\n\r\nexport type InstructionGroup = { type: '@instruction-group', instructions: Instruction[] }\r\n\r\nexport type Instruction =\r\n  | Arc\r\n  | ClearRect\r\n  | BeginPath\r\n  | Stroke\r\n  | Fill\r\n  | LineWidth\r\n  | StrokeStyle\r\n  | FillStyle\r\n  | MoveTo\r\n  | ClosePath\r\n  | LineTo\r\n  | Save\r\n  | Restore\r\n  | InstructionGroup\r\n\r\nexport type Tagged<T> = { type: \"@tag\"; instructions: Instruction[]; data: T };\r\n\r\nexport const tag = (instructions: Instruction[]) => <T>(\r\n  data: T\r\n): Tagged<T> => ({ type: \"@tag\", instructions, data });\r\n\r\nexport const group = (instructions: Instruction[]): InstructionGroup => ({\r\n    type: '@instruction-group', instructions\r\n})\r\n\r\nexport interface Canvas {\r\n  [uri]: {\r\n    canvas: T.UIO<HTMLCanvasElement>;\r\n    clearRect: (\r\n      x?: number,\r\n      y?: number,\r\n      width?: number,\r\n      height?: number\r\n    ) => T.RUIO<Canvas, Instruction>;\r\n    arc: (\r\n      x: number,\r\n      y: number,\r\n      radius: number,\r\n      startAngle: Radian,\r\n      endAngle: Radian,\r\n      anticlockwise?: boolean | undefined\r\n    ) => T.UIO<Instruction>;\r\n    lineTo: (\r\n      x: number,\r\n      y: number,\r\n    ) => T.UIO<Instruction>;\r\n    moveTo: (\r\n      x: number,\r\n      y: number,\r\n    ) => T.UIO<Instruction>;\r\n    lineWidth: (width: number) => T.UIO<Instruction>;\r\n    beginPath: T.UIO<Instruction>;\r\n    closePath: T.UIO<Instruction>;\r\n    stroke: T.UIO<Instruction>;\r\n    save: T.UIO<Instruction>;\r\n    restore: T.UIO<Instruction>;\r\n    fill: T.UIO<Instruction>;\r\n    strokeStyle: (color: string) => T.UIO<Instruction>;\r\n    fillStyle: (color: string) => T.UIO<Instruction>;\r\n  };\r\n}\r\n\r\n/**\r\n * circle :: number -> number -> number -> number? -> number? -> Effect Canvas never (number, number, number)\r\n *\r\n * Draws a circle on the canvas. X, y, and radius are returned again.\r\n */\r\nexport const circle = (\r\n  x: number,\r\n  y: number,\r\n  r: number,\r\n  sa?: number,\r\n  ea?: number\r\n) =>\r\n  T.accessM((_: Canvas) => {\r\n    const ctx = _[uri];\r\n    return pipe(\r\n      T.zip(\r\n        sa ? T.pure(sa) : fromIO(Rnd.randomInt(0, 360)),\r\n        ea\r\n          ? T.pure(ea)\r\n          : fromIO(Rnd.randomInt((Math.PI / 10) * 1000, Math.PI * 1000))\r\n      ),\r\n      T.chain(([sa, ea]) => {\r\n        const list: T.UIO<Instruction>[] = [\r\n          pipe(rndColor(1), T.chain(ctx.strokeStyle)),\r\n          pipe(rndColor(), T.chain(ctx.fillStyle)),\r\n          ctx.lineWidth(2),\r\n          ctx.beginPath,\r\n          ctx.arc(x, y, r, sa, ea / 1000),\r\n          ctx.stroke,\r\n          ctx.fill,\r\n        ];\r\n\r\n        return A.array.sequence(T.effect)(list);\r\n      })\r\n    );\r\n  });\r\n\r\n/**\r\n * clear :: T.Effect Canvas never void\r\n *\r\n * Clears a canvas\r\n */\r\nexport const clear = T.accessM((_: Canvas) => _[uri].clearRect());\r\n\r\nconst accessCanvas = T.accessM((_: Canvas) => _[uri].canvas);\r\n\r\nconst accessCanvasProp = <TProp extends keyof HTMLCanvasElement>(prop: TProp) =>\r\n  pipe(\r\n    accessCanvas,\r\n    T.map((el) => el[prop])\r\n  );\r\n\r\nconst canvasPropIfNot = <TProp extends keyof HTMLCanvasElement>(\r\n  prop: TProp\r\n) => (value?: HTMLCanvasElement[TProp]) =>\r\n  value != null ? T.pure(value) : accessCanvasProp(prop);\r\n\r\nconst canvasWidthIfNot = canvasPropIfNot(\"width\");\r\nconst canvasHeightIfNot = canvasPropIfNot(\"height\");\r\n\r\nconst makeClearRectLive = (ctx: CanvasRenderingContext2D) => (\r\n  x?: number,\r\n  y?: number,\r\n  width?: number,\r\n  height?: number\r\n): T.Effect<Canvas, never, ClearRect> =>\r\n  Do(T.effect)\r\n    .bind(\"width\", canvasWidthIfNot(width))\r\n    .bind(\"height\", canvasHeightIfNot(height))\r\n    .doL(({ width, height }) =>\r\n      T.sync(() => ctx.clearRect(x || 0, y || 0, width, height))\r\n    )\r\n    .return(({ width, height }) => ({\r\n      type: \"@instruction/clearRect\",\r\n      args: tuple(x || 0, y || 0, width, height),\r\n    }));\r\n\r\nexport const isInstruction = <TInstructionType extends Instruction[\"type\"]>(\r\n  type: TInstructionType\r\n) => (\r\n  instruction: Instruction\r\n): instruction is Extract<Instruction, { type: TInstructionType }> =>\r\n  instruction.type === type;\r\n\r\nexport const parseInstruction = (instruction: Instruction) =>\r\n  T.accessM((_: Canvas): T.Effect<Canvas, never, Instruction> => {\r\n    const ctx = _[uri];\r\n\r\n    switch (instruction.type) {\r\n       case \"@instruction-group\": {\r\n        return pipe(\r\n            parseInstructions(instruction.instructions),\r\n            T.map(group)\r\n        )\r\n       }\r\n      case \"@instruction/arc\": {\r\n        return ctx.arc(...instruction.args);\r\n      }\r\n      case \"@instruction/lineTo\": {\r\n        return ctx.lineTo(...instruction.args);\r\n      }\r\n      case \"@instruction/moveTo\": {\r\n        return ctx.moveTo(...instruction.args);\r\n      }\r\n      case \"@instruction/save\": {\r\n        return ctx.save;\r\n      }\r\n      case \"@instruction/restore\": {\r\n        return ctx.restore;\r\n      }\r\n      case \"@instruction/beginPath\": {\r\n        return ctx.beginPath;\r\n      }\r\n      case \"@instruction/closePath\": {\r\n        return ctx.closePath;\r\n      }\r\n      case \"@instruction/clearRect\": {\r\n        return ctx.clearRect(...instruction.args);\r\n      }\r\n      case \"@instruction/fill\": {\r\n        return ctx.fill\r\n      }\r\n      case \"@instruction/fillStyle\": {\r\n        return ctx.fillStyle(...instruction.args);\r\n      }\r\n      case \"@instruction/lineWidth\": {\r\n        return ctx.lineWidth(...instruction.args);\r\n      }\r\n      case \"@instruction/stroke\": {\r\n        return ctx.stroke;\r\n      }\r\n      case \"@instruction/strokeStyle\": {\r\n        return ctx.strokeStyle(...instruction.args);\r\n      }\r\n    }\r\n  });\r\n\r\nexport const parseInstructions = (instructions: Instruction[]) => pipe(\r\n    instructions,\r\n    A.map(parseInstruction),\r\n    A.array.sequence(T.effect)\r\n)\r\n\r\nexport const makeCanvasLive = (ctx: CanvasRenderingContext2D): Canvas => {\r\n  return {\r\n    [uri]: {\r\n      canvas: T.pure(ctx.canvas),\r\n      arc: (\r\n        x: number,\r\n        y: number,\r\n        radius: number,\r\n        startAngle: Radian,\r\n        endAngle: Radian,\r\n        anticlockwise = false\r\n      ) =>\r\n        T.as(\r\n          T.sync(() =>\r\n            ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise)\r\n          ),\r\n          {\r\n            type: \"@instruction/arc\",\r\n            args: [x, y, radius, startAngle, endAngle, anticlockwise],\r\n          }\r\n        ),\r\n      lineTo: (\r\n        x: number,\r\n        y: number,\r\n      ) =>\r\n        T.as(\r\n          T.sync(() =>\r\n            ctx.lineTo(x, y)\r\n          ),\r\n          {\r\n            type: \"@instruction/lineTo\",\r\n            args: [x, y],\r\n          }\r\n        ),\r\n      moveTo: (\r\n        x: number,\r\n        y: number,\r\n      ) =>\r\n        T.as(\r\n          T.sync(() =>\r\n            ctx.moveTo(x, y)\r\n          ),\r\n          {\r\n            type: \"@instruction/moveTo\",\r\n            args: [x, y],\r\n          }\r\n        ),\r\n      clearRect: makeClearRectLive(ctx),\r\n      beginPath: T.as(\r\n        T.sync(() => ctx.beginPath()),\r\n        { type: \"@instruction/beginPath\" }\r\n      ),\r\n      closePath: T.as(\r\n        T.sync(() => ctx.closePath()),\r\n        { type: \"@instruction/closePath\" }\r\n      ),\r\n      stroke: T.as(\r\n        T.sync(() => ctx.stroke()),\r\n        { type: \"@instruction/stroke\" }\r\n      ),\r\n      save: T.as(\r\n        T.sync(() => ctx.save()),\r\n        { type: \"@instruction/save\" }\r\n      ),\r\n      restore: T.as(\r\n        T.sync(() => ctx.restore()),\r\n        { type: \"@instruction/restore\" }\r\n      ),\r\n      fill: T.as(\r\n        T.sync(() => ctx.fill()),\r\n        { type: \"@instruction/fill\" }\r\n      ),\r\n      lineWidth: (width: number) =>\r\n        T.as(\r\n          T.sync(() => {\r\n            ctx.lineWidth = Math.abs(width);\r\n          }),\r\n          { type: \"@instruction/lineWidth\", args: [width] }\r\n        ),\r\n      strokeStyle: (color: string) =>\r\n        T.as(\r\n          T.sync(() => {\r\n            ctx.strokeStyle = color;\r\n          }),\r\n          { type: \"@instruction/strokeStyle\", args: [color] }\r\n        ),\r\n      fillStyle: (color: string) =>\r\n        T.as(\r\n          T.sync(() => {\r\n            ctx.fillStyle = color;\r\n          }),\r\n          { type: \"@instruction/fillStyle\", args: [color] }\r\n        ),\r\n    },\r\n  };\r\n};\r\n\r\nexport const moveTo = ([x, y]: [number, number]) => T.accessM(\r\n    (_: Canvas) => _[uri].moveTo(x, y)\r\n)\r\n\r\nexport const lineTo = ([x, y]: [number, number]) => T.accessM(\r\n    (_: Canvas) => _[uri].lineTo(x, y)\r\n)\r\n\r\nexport const lineWidth = (width: number) => T.accessM(\r\n    (_: Canvas) => _[uri].lineWidth(width)\r\n)\r\n\r\nexport const beginPath = T.accessM(\r\n    (_: Canvas) => _[uri].beginPath\r\n)\r\n\r\nexport const closePath = T.accessM(\r\n    (_: Canvas) => _[uri].closePath\r\n)\r\n\r\nexport const stroke = T.accessM(\r\n    (_: Canvas) => _[uri].stroke\r\n)\r\n\r\nexport const accessContext = <R, E, A>(f: (ctx: Canvas[typeof uri]) => T.Effect<Canvas & R, E, A>) => T.accessM((_: Canvas) => f(_[uri]))","import { effect as T, stream as S, managed as M } from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { dot } from \"../../utils/getter\";\r\nimport { log } from \"@matechs/console\";\r\n\r\nexport const uri = \"@uri/emitter\";\r\n\r\ntype EventFor<TEventType extends string> = TEventType extends\r\n  | \"keypress\"\r\n  | \"keyup\"\r\n  | \"keydown\"\r\n  ? KeyboardEvent\r\n  : TEventType extends \"click\" | \"dblclick\" | \"mousemove\"\r\n  ? MouseEvent\r\n  : Event;\r\n\r\ntype EventHandler<TEventType extends string> = (\r\n  evt: EventFor<TEventType>\r\n) => void;\r\n\r\nexport interface Emitter {\r\n  [uri]: {\r\n    fromEvent: <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<T.NoEnv, never, void>;\r\n    addEventListener: <THTMLElement extends HTMLElement>(\r\n      el: THTMLElement\r\n    ) => <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<T.NoEnv, never, void>;\r\n  };\r\n}\r\n\r\n// Events\r\nexport const subscribe = <\r\n  TEventType extends string,\r\n  THTMLElement extends HTMLElement\r\n>(\r\n  type: TEventType,\r\n  el?: THTMLElement\r\n) => {\r\n  return S.fromSource(\r\n    M.managed.chain(\r\n      M.bracket(\r\n        T.accessM((_: Emitter) =>\r\n          T.sync(() => {\r\n            const { next, ops, hasCB } = S.su.queueUtils<\r\n              never,\r\n              EventFor<TEventType>\r\n            >();\r\n\r\n            const fn = el ? _[uri].addEventListener(el) : _[uri].fromEvent;\r\n\r\n            return {\r\n              unsubscribe: fn(type)((a) => next({ _tag: \"offer\", a })),\r\n              ops,\r\n              hasCB,\r\n            };\r\n          })\r\n        ),\r\n        dot(\"unsubscribe\")\r\n      ),\r\n      ({ ops, hasCB }) => S.su.emitter(ops, hasCB)\r\n    )\r\n  );\r\n};\r\n\r\nexport const makeEmitterLive = <\r\n  TRoot extends Pick<HTMLElement, \"addEventListener\" | \"removeEventListener\">\r\n>(\r\n  rootEl: TRoot\r\n): Emitter => {\r\n  return {\r\n    [uri]: {\r\n      fromEvent: <TEventType extends string>(type: TEventType) => (\r\n        cb: EventHandler<TEventType>\r\n      ) => {\r\n        rootEl.addEventListener(type, cb as any);\r\n\r\n        return T.sync(() => rootEl.removeEventListener(type, cb as any));\r\n      },\r\n      addEventListener: <THTMLElement extends HTMLElement>(\r\n        el: THTMLElement\r\n      ) => <TEventType extends string>(type: TEventType) => (\r\n        cb: EventHandler<TEventType>\r\n      ) => {\r\n        el.addEventListener(type, cb as any);\r\n\r\n        return T.sync(() => el.removeEventListener(type, cb as any));\r\n      },\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * waitForKeyPress :: number -> Effect NoEnv never void\r\n *\r\n * Given a keyCode returns an effect that resolves once the user\r\n * presses a key on the keyboard matching the key code.\r\n */\r\nexport const waitForKeyPress = (...keyCodes: number[]) =>\r\n  T.effect.chain(log(\"Waiting for \", ...keyCodes), () =>\r\n    pipe(\r\n      subscribe(\"keyup\"),\r\n      S.filter((event) => keyCodes.includes(event.keyCode)),\r\n      S.take(1),\r\n      S.collectArray,\r\n      T.map(([evt]) => evt)\r\n    )\r\n  );\r\n","export const charCodeAt = (at: number) => (str: string) => str.charCodeAt(at)","import * as React from \"react\";\r\n\r\nimport { effect as T, stream as S, ref } from \"@matechs/effect\";\r\nimport { provideConsole } from \"@matechs/console\";\r\nimport * as Rnd from \"fp-ts/lib/Random\";\r\nimport * as A from \"fp-ts/lib/Array\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\n\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { flow, identity, constant } from \"fp-ts/lib/function\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\nimport { dot } from \"../../utils/getter\";\r\n\r\nimport * as Canvas from \"../../modules/canvas\";\r\nimport * as Emitter from \"../../modules/emitter\";\r\nimport { fromIO, takeUntil } from \"../../utils/effect\";\r\nimport { tuple } from \"../../utils/tuple\";\r\nimport { charCodeAt } from \"../../utils/string\";\r\n\r\ntype X = number;\r\ntype Y = number;\r\ntype Radius = number;\r\ntype Angle = number;\r\ntype StartAngle = Angle;\r\ntype EndAngle = Angle;\r\ntype TimeStamp = number;\r\n\r\ntype Circle = [X, Y, Radius, StartAngle, EndAngle];\r\ntype TimeStamped = [X, Y, Radius, StartAngle, EndAngle, TimeStamp];\r\n\r\n/**\r\n * ```hs\r\n * randomCircle :: (number, number) -> Stream Canvas never Circle\r\n * ```\r\n *\r\n * Draws a circle with a random radius\r\n */\r\nconst randomCircle = ([x, y]: [X, Y]) =>\r\n  pipe(\r\n    // Get a random radius for the circle to draw\r\n    Rnd.randomInt(30, 200),\r\n    // Convert IO to Effect\r\n    fromIO,\r\n    // Map effect that produces a random int to an effect that draws a circle\r\n    T.chain((r) => Canvas.circle(x, y, r)),\r\n    T.map((instructions) => Canvas.group(instructions))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n * mapMouseEventToCoord :: MouseEvent -> (X, Y\r\n * ```\r\n */\r\nconst mapMouseEventToCoord = (e: MouseEvent) => tuple(e.offsetX, e.offsetY);\r\n\r\nconst makeOnClick = <R, E, A>(\r\n  makeEffect: ([x, y]: [X, Y]) => T.Effect<R, E, A>\r\n) =>\r\n  pipe(\r\n    // Read canvas element from environment\r\n    T.accessM((_: Canvas.Canvas) => _[Canvas.uri].canvas),\r\n    // Turn it into a stream\r\n    S.encaseEffect,\r\n    // Flat map the 1 element stream containing the canvas element to a stream of mouse clicks\r\n    S.chain((canvasEl) =>\r\n      // encaseObservable(fromEvent<MouseEvent>(canvasEl, \"click\"), constVoid)\r\n      Emitter.subscribe(\"click\", canvasEl)\r\n    ),\r\n    //   // Take mouse clicks until the user presses d or D\r\n    //   takeUntil(Emitter.waitForKeyPress(68)),\r\n    // Map the mouse event to it's coordinates\r\n    S.map(mapMouseEventToCoord),\r\n    // Flat map the stream of coordinates to\r\n    // a stream that draws a circle\r\n    S.chain(flow(makeEffect, S.encaseEffect))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n * drawCirclesOnClick :: Effect (Console & Canvas & Emitter) never [TimeStamped]\r\n * ```\r\n *\r\n * Draw a circle on every mouseclick until the program is terminated by pressing 'd' or 'D'\r\n */\r\nconst drawCirclesOnClick = makeOnClick(randomCircle);\r\n\r\n/**\r\n * Draw a marker\r\n */\r\nconst marker = ([x, y]: [number, number]) =>\r\n  Canvas.accessContext((ctx) =>\r\n    pipe(\r\n      [\r\n        ctx.beginPath,\r\n        ctx.arc(x, y, 3, 0, Math.PI * 2),\r\n        ctx.strokeStyle(\"#000000\"),\r\n        ctx.fillStyle(\"#ffffff\"),\r\n        ctx.lineWidth(2),\r\n        ctx.stroke,\r\n        ctx.fill,\r\n      ],\r\n      A.array.sequence(T.effect),\r\n      T.map(Canvas.group)\r\n    )\r\n  );\r\n\r\nconst drawMarkerOnClick = makeOnClick(marker);\r\n\r\n/**\r\n * Take one element from a stream and return it as an effect.\r\n */\r\nconst takeOne = <R, E, A>(stream: S.Stream<R, E, A>) =>\r\n  pipe(\r\n    stream,\r\n    S.take(1),\r\n    S.collectArray,\r\n    T.map(([a]) => a)\r\n  );\r\n\r\nconst polygonCoordinates2Effect = ([h, ...t]: [number, number][]) =>\r\n  pipe(\r\n    A.array.sequence(T.effect)(\r\n      pipe([\r\n        Canvas.beginPath,\r\n        Canvas.lineWidth(1),\r\n        Canvas.accessContext(ctx => ctx.strokeStyle('#000')),\r\n        // Move the cursor the head of the set of coordinates.\r\n        Canvas.moveTo(h),\r\n        // From there draw a line to every next coordinate\r\n        ...t.map(Canvas.lineTo),\r\n        Canvas.closePath,\r\n        Canvas.stroke,\r\n        // Draw a marker for the head position\r\n        marker(h),\r\n        // And every other.\r\n        ...t.map(marker),\r\n      ])\r\n    ),\r\n    T.map(Canvas.group)\r\n  );\r\n\r\n/**\r\n * Let the user draw a polygon.\r\n * @param onState The current state of the canvas. This is needed to redraw it on every mouse move.\r\n */\r\nconst drawPolygon = (currentState: Canvas.Instruction[]) => {\r\n  // Effect that will restore the canvas to it's original\r\n  const restoreCanvas = pipe(\r\n    currentState,\r\n    A.map(Canvas.parseInstruction),\r\n    A.array.sequence(T.effect)\r\n  );\r\n\r\n  return pipe(\r\n    // Create a ref to store the coordinates of the new polygon in.\r\n\r\n    ref.makeRef({\r\n      coords: [] as [number, number][],\r\n      instructionGroup: O.none as O.Option<Canvas.InstructionGroup>,\r\n    }),\r\n    S.encaseEffect,\r\n    S.chain((polygonRef) =>\r\n      //   T.zip(\r\n      pipe(\r\n        // Wait for the user to assign the first coordinate by clicking on the canvas.\r\n        takeOne(Emitter.subscribe(\"click\")),\r\n        T.map(mapMouseEventToCoord),\r\n        // Store the first coordinate using the reference\r\n        T.chain((coord) =>\r\n          polygonRef.set({ coords: [coord], instructionGroup: O.none })\r\n        ),\r\n        // Continue as a stream\r\n        S.encaseEffect,\r\n        S.chain(\r\n          constant(\r\n            pipe(\r\n              // Race between mousemove and click\r\n              T.race(\r\n                takeOne(Emitter.subscribe(\"click\")),\r\n                takeOne(Emitter.subscribe(\"mousemove\"))\r\n              ),\r\n              // Chain mousevent to drawing the polygon\r\n              T.chain((event) =>\r\n                pipe(\r\n                  event,\r\n                  mapMouseEventToCoord,\r\n                  (coord) =>\r\n                    event.type === \"click\"\r\n                    // If click won the race, update the reference with the new coordinate\r\n                      ? pipe(\r\n                          polygonRef.update(({ coords, instructionGroup }) => ({\r\n                            coords: [...coords, coord],\r\n                            instructionGroup,\r\n                          })),\r\n                          // Retain the set of coordinates from the update\r\n                          T.map(dot(\"coords\"))\r\n                        )\r\n                        // If mousemove won the race, get the coordiantes from the reference\r\n                        // and concat the \"move\" coordinate.\r\n                      : pipe(\r\n                          polygonRef.get,\r\n                          T.map(({ coords }) => [...coords, coord])\r\n                        ),\r\n                        // Retain the coordinates to be drawn with the event type\r\n                  T.map((coords) => tuple(event.type, coords))\r\n                )\r\n              ),\r\n              T.chain(([eventType, coords]) =>\r\n                Do(T.effect)\r\n                // Clear the canvas\r\n                  .do(Canvas.clear)\r\n                  // Restore what was already previously drawn\r\n                  .do(restoreCanvas)\r\n                  // Draw the polygon and stream the instructions\r\n                  .bind(\r\n                    \"polygonInstructions\",\r\n                    polygonCoordinates2Effect(coords)\r\n                  )\r\n                  // Update the reference to the instructions\r\n                  .doL(({ polygonInstructions }) =>\r\n                    eventType === \"click\" && coords.length > 2\r\n                      ? polygonRef.update(({ coords, instructionGroup }) => ({\r\n                          coords,\r\n                          instructionGroup: O.some(polygonInstructions),\r\n                        }))\r\n                      : T.pure(1)\r\n                  )\r\n                  .done()\r\n              ),\r\n              S.encaseEffect,\r\n              // Rinse and repeat the race\r\n              S.repeat,\r\n            )\r\n          )\r\n        ),\r\n        // The stream output is the instruction group collected on the reference\r\n        S.chain(constant(pipe(\r\n            polygonRef.get,\r\n            T.map(dot('instructionGroup')),\r\n            S.encaseEffect\r\n        ))),\r\n      )\r\n    )\r\n  );\r\n};\r\n\r\nconst makeWaitForMenuChoice = (menuCodes: number[]) =>\r\n  pipe(\r\n    Emitter.subscribe(\"keyup\"),\r\n    S.map(dot(\"keyCode\")),\r\n    S.filter(menuCodes.includes.bind(menuCodes)),\r\n    S.take(1),\r\n    S.collectArray,\r\n    T.map(([keyCode]) => keyCode),\r\n    T.map(String.fromCharCode)\r\n  );\r\n\r\nconst waitForMainMenuChoice = pipe(\r\n  [\"1\", \"2\", \"3\", \"R\", \"X\"],\r\n  A.map(charCodeAt(0)),\r\n  makeWaitForMenuChoice\r\n);\r\n\r\nconst waitForToolMenuChoice = pipe(\r\n  [\"S\", \"X\"],\r\n  A.map(charCodeAt(0)),\r\n  makeWaitForMenuChoice\r\n);\r\n\r\nconst makeDoUntilMenuChoice = <R, E, A>(\r\n  effect: S.Stream<R, E, A>\r\n): T.Effect<R & Emitter.Emitter, E, O.Option<A[]>> =>\r\n  pipe(\r\n    // Run 2 effects in parallell\r\n    T.parZip(\r\n      // One that runs the effect until a menu choice (S or X) is pressed\r\n      pipe(effect, takeUntil(waitForToolMenuChoice), S.collectArray),\r\n      // And second the menu choice itself\r\n      waitForToolMenuChoice\r\n    ),\r\n    // If the menu choice was X return an empty list of instructions otherwise return instructions.\r\n    T.map(([instructions, code]) =>\r\n      code === \"S\" ? O.some(instructions) : O.none\r\n    )\r\n  );\r\n\r\ntype EffectOf<T> = T extends T.Effect<any, any, infer A> ? A : never;\r\n\r\n/**\r\n * Main program\r\n */\r\nconst main = Do(T.effect)\r\n  // Create a ref that stores canvas drawings as serializable instructions.\r\n  .bind(\r\n    \"stateRef\",\r\n    ref.makeRef({\r\n      instructions: [] as Canvas.Instruction[],\r\n    })\r\n  )\r\n  .doL(({ stateRef }) =>\r\n    // Use the ref in a program that runs forever.,\r\n    T.forever(\r\n      Do(T.effect)\r\n        // Clear the canvas on every run.\r\n        .do(Canvas.clear)\r\n        // Convert the instructions in state to effects that draw onto the canvas.\r\n        .do(\r\n          pipe(\r\n            stateRef.get,\r\n            T.chain((state) => Canvas.parseInstructions(state.instructions))\r\n          )\r\n        )\r\n        // Wait for the user to make a choice (1, 2, or X)\r\n        .bind(\"mainMenuChoice\", waitForMainMenuChoice)\r\n        // Allow the user to draw on canvas or clear it if the choice was X\r\n        .bindL(\"additionalInstructions\", ({ mainMenuChoice }) => {\r\n          switch (mainMenuChoice) {\r\n            case \"1\": {\r\n              const program = makeDoUntilMenuChoice(drawCirclesOnClick);\r\n              return program;\r\n            }\r\n            case \"2\": {\r\n              const program = makeDoUntilMenuChoice(drawMarkerOnClick);\r\n              return program;\r\n            }\r\n            case \"3\": {\r\n              const program = pipe(\r\n                // Let the user draw a polygon until they press S or X (to cancel)\r\n                makeDoUntilMenuChoice(\r\n                  pipe(\r\n                    stateRef.get,\r\n                    T.map(dot(\"instructions\")),\r\n                    S.encaseEffect,\r\n                    S.chain(drawPolygon),\r\n                  )\r\n                ),\r\n                // makeDoUntilMenuChoice returns an option to indicate cancellation\r\n                T.map(option => pipe(\r\n                    option,\r\n                    // drawPolygon also returns an option and is a stream (array) of options\r\n                    O.chain(suboptions => pipe(\r\n                        suboptions,\r\n                        // We only want the last polygon since that was the final version\r\n                        A.reverse,\r\n                        ([h]) => h,\r\n                    )),\r\n                    // Put it back into an array (the other 2 programs emit arrays)\r\n                    O.map(A.of)\r\n                )),\r\n              );\r\n\r\n              return program;\r\n            }\r\n            case \"X\": {\r\n              // Empty the instructions in state\r\n              return T.as(\r\n                stateRef.update(() => ({ instructions: [] })),\r\n                O.none as O.Option<Canvas.InstructionGroup[]>\r\n              );\r\n            }\r\n            default:\r\n              return T.pure(O.none as O.Option<Canvas.InstructionGroup[]>);\r\n          }\r\n        })\r\n        // Update state and add the new set of instructions to the current set\r\n        .doL(({ additionalInstructions }) => {\r\n          console.log(additionalInstructions);\r\n          return pipe(\r\n            additionalInstructions,\r\n            O.map((instructions) =>\r\n              T.as(\r\n                stateRef.update((current) => {\r\n                  return {\r\n                    instructions: [...current.instructions, ...instructions],\r\n                  };\r\n                }),\r\n                1\r\n              )\r\n            ),\r\n            O.fold(constant(T.pure(1)), identity)\r\n          );\r\n        })\r\n        .done()\r\n    )\r\n  )\r\n  .done();\r\n\r\nexport const useCircles = (\r\n  canvasRef: React.MutableRefObject<HTMLCanvasElement | null>\r\n) =>\r\n  React.useEffect(() => {\r\n    if (canvasRef.current) {\r\n      const ctx = canvasRef.current.getContext(\"2d\");\r\n\r\n      if (ctx) {\r\n        pipe(\r\n          // Run the main program\r\n          main,\r\n          //   T.forever,\r\n          // Provide Emitter which adds support for listening to mouse clicks and keyboard presses\r\n          T.provideS(Emitter.makeEmitterLive(document)),\r\n          // Provide the canvas 2d context\r\n          T.provideS(Canvas.makeCanvasLive(ctx)),\r\n          // Provide console logging capabilities\r\n          provideConsole,\r\n          T.run\r\n        );\r\n      }\r\n    }\r\n  }, [canvasRef]);\r\n","import \"./App.scss\";\n\nimport React from \"react\";\nimport { tuple } from \"./utils/tuple\";\nimport * as Circles from './apps/circles'\n\n// Hooks\nconst useCanvasRef = () => React.useRef<HTMLCanvasElement | null>(null);\nconst useSizeState = () => React.useState(tuple(0, 0));\n\nconst useCanvas = () => {\n  const ref = useCanvasRef()\n  const [[width, height], setSize] = useSizeState()\n\n  React.useEffect(() => {\n    setTimeout(() => {\n      if (ref.current && ref.current.parentElement) {\n        console.log(ref.current.parentElement.getBoundingClientRect());\n        const {\n          width,\n          height,\n        } = ref.current.parentElement.getBoundingClientRect();\n        setSize(tuple(width, height));\n      }\n    }, 1);\n  }, [ref, setSize]);\n  \n  return tuple(<canvas height={height} width={width} ref={ref}></canvas>, ref)\n}\n\nfunction App() {\n  const [canvas, ref] = useCanvas()\n  Circles.useCircles(ref)\n\n  return (\n    <div id=\"app\">\n      <section>\n        {canvas}\n      </section>\n      <footer>\n        <ul>\n          <li>\n            Press <strong>1</strong> to enter \"circles\" mode. Once in this mode you can click anywhere to draw a random circle.\n            <ul>\n              <li>\n                Press <strong>S</strong> to save or <strong>X</strong> to cancel. You will be taken back to main mode.\n              </li>\n            </ul>\n          </li>\n          <li>\n            Press <strong>2</strong> to enter \"markers\" mode. Once in this mode you can click anywhere to draw a yellow marker.\n            <ul>\n              <li>\n                Press <strong>S</strong> to save or <strong>X</strong> to cancel. You will be taken back to main mode.\n              </li>\n            </ul>\n          </li>\n          <li>\n            Press <strong>3</strong> to enter \"polygon\" mode. Once in this mode you can click anywhere to draw a polygon.\n            <ul>\n              <li>\n                Press <strong>S</strong> to save or <strong>X</strong> to cancel. You will be taken back to main mode.\n              </li>\n            </ul>\n          </li>\n          <li>\n            Press <strong>X</strong> while in <i>main</i> mode to clear the canvas.\n          </li>\n        </ul>\n        <p>\n          Circles have a random radius, start angle, end angle, color and border color.\n        </p>\n      </footer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.scss\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}