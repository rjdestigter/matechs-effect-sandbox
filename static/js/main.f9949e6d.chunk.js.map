{"version":3,"sources":["serviceWorker.ts","utils/getter.ts","utils/effect.ts","utils/tuple.ts","modules/dom/index.ts","modules/canvas/index.ts","modules/emitter/index.ts","utils/string.ts","components/buttons/make.ts","components/buttons/add-polygon.ts","components/buttons/add-circles.ts","components/buttons/add-markers.ts","components/buttons/save.ts","components/buttons/cancel.ts","components/buttons/clear.ts","apps/circles/index.ts","index.ts"],"names":["Boolean","window","location","hostname","match","getter","key","o","getter2","k1","k2","dot","fromIO","io","T","sync","rndColor","alpha","Do","effect","bind","Rnd","pure","pipe","IO","a","return","r","g","b","takeUntil","until","s","stream","wrappedUntil","S","as","type","encaseEffect","wrappedStream","map","value","mergeAll","takeWhile","wrapped","filter","takeUntil_","eventType","f","tuple","ts","uri","group","instructions","clear","accessM","_","clearRect","accessCanvas","canvas","canvasPropIfNot","prop","el","accessCanvasProp","canvasWidthIfNot","canvasHeightIfNot","makeClearRectLive","ctx","x","y","width","height","doL","args","parseInstruction","instruction","parseInstructions","arc","lineTo","moveTo","save","restore","beginPath","closePath","fill","fillStyle","lineWidth","stroke","strokeStyle","A","sequence","accessContext","subscribe","ret","fromSource","M","managed","chain","bracket","su","queueUtils","next","ops","hasCB","unsubscribe","addEventListener","fromEvent","fn","_tag","emitter","charCodeAt","at","str","getDocument","flow","querySelector","selectors","O","$","parentElement","node","EmptyOptionOfElement","message","name","Error","raiseEmptyOptionOfElement","raiseError","makeClickStream","elementT","elementO","constant","raised","identity","selector","element","clicks","withButton","error","cb","btn","disable","setAttribute","enable","removeAttribute","make","mapMouseEventToCoord","e","offsetX","offsetY","makeOnClick","makeEffect","Canvas","Emitter","drawCirclesOnClick","sa","ea","zip","Math","PI","list","marker","drawMarkerOnClick","takeOne","take","collectArray","restoreCanvas","drawPolygon","ref","makeRef","coords","instructionGroup","polygonRef","canvasO","coord","set","race","event","update","get","do","colour","h","t","polygonCoordinates2Effect","polygonInstructions","length","done","repeat","makeWaitForMenuChoice","menuCodes","includes","String","fromCharCode","waitForAddPolygonButtonClick","addPolygonBtn","waitForCirclesButtonClick","addCircleBtn","waitForAddMarkersButtonClick","addMarkersBtn","waitForSaveButtonClick","saveBtn","waitForAddCancelButtonClick","cancelBtn","waitForClearButtonClick","clearBtn","waitForMainMenuChoice","choice","waitForToolMenuChoice","makeDoUntilMenuChoice","parZip","foo","main","bindL","stateRef","state","constVoid","forever","hasInstructions","mainMenuChoice","option","suboptions","provideS","additionalInstructions","current","voidEffect","program","doc","parent","getBoundingClientRect","onmousedown","Circles","rootEl","stopPropagation","removeEventListener","getContext","radius","startAngle","endAngle","anticlockwise","abs","color","snd","document","provideConsole","run","navigator","serviceWorker","ready","then","registration","unregister","catch","console"],"mappings":"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","file":"static/js/main.f9949e6d.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","/**\r\n * @packageDocumentation\r\n * @module utils\r\n */\r\n\r\n/**\r\n * Type that describes a function that returns\r\n * the value of on object's property given\r\n *\r\n * @typeparam TKey The key or property name the function should read and return from a given object.\r\n * @typeparam TValue The value type\r\n * @typeparam TObject The object type\r\n */\r\nexport type Getter<TKey extends string> = <\r\n  TValue,\r\n  TObject extends {\r\n    [P in TKey]: TValue;\r\n  }\r\n>(\r\n  o: TObject\r\n) => TObject[TKey];\r\n\r\n/**\r\n *\r\n * @param key\r\n */\r\nexport const getter = <K extends string>(key: K): Getter<K> => <\r\n  T,\r\n  O extends { [P in K]: T }\r\n>(\r\n  o: O\r\n) => o[key];\r\n\r\nexport const getter2 = <K1 extends string, K2 extends string>(\r\n  k1: K1,\r\n  k2: K2\r\n) => <T, O extends { [P in K1]: { [R in K2]: T } }>(o: O) => o[k1][k2];\r\n\r\nexport const dot = getter;\r\nexport const dot2 = getter2;\r\nexport const pluck = getter;\r\nexport const pluck2 = getter2;\r\n\r\nexport const getEventCurrentTargetValue = dot2(\"detail\", \"value\");\r\n","import * as IO from \"fp-ts/lib/IO\";\r\nimport * as Rnd from \"fp-ts/lib/Random\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\nimport { effect as T, stream as S } from \"@matechs/effect\";\r\n\r\nexport const fromIO = <T>(io: IO.IO<T>) => {\r\n  return T.sync(() => io());\r\n};\r\n\r\nexport const rndColor = (alpha?: number) =>\r\n  Do(T.effect)\r\n    .bind(\"r\", fromIO(Rnd.randomInt(0, 255)))\r\n    .bind(\"g\", fromIO(Rnd.randomInt(0, 255)))\r\n    .bind(\"b\", fromIO(Rnd.randomInt(0, 255)))\r\n    .bind(\r\n      \"a\",\r\n      alpha != null\r\n        ? T.pure(alpha)\r\n        : fromIO(\r\n            pipe(\r\n              Rnd.randomInt(0, 10),\r\n              IO.map((a) => a / 10)\r\n            )\r\n          )\r\n    )\r\n    .return(({ r, g, b, a }) => `rgba(${r}, ${g}, ${b}, ${a})`);\r\n\r\n/**\r\n * Take elements from a stream until a given effect resolves.\r\n *\r\n * @param until The effect that will terminate the stream\r\n * @param stream The stream\r\n */\r\nfunction takeUntil_<R1, E1, R2, E2, A>(\r\n  stream: S.Stream<R1, E1, A>,\r\n  until: T.Effect<R2, E2, any>\r\n) {\r\n  type Wrapped = { type: \"until\" } | { type: \"stream\"; value: A };\r\n\r\n  const wrappedUntil = S.as<Wrapped>({ type: \"until\" })(S.encaseEffect(until));\r\n\r\n  const wrappedStream = pipe(\r\n    stream,\r\n    S.map((value): Wrapped => ({ type: \"stream\", value }))\r\n  );\r\n\r\n  return pipe(\r\n    S.mergeAll([wrappedUntil as any, wrappedStream as any] as S.Stream<\r\n      R1 & R2,\r\n      E1 | E2,\r\n      Wrapped\r\n    >[]),\r\n    S.takeWhile((wrapped) => wrapped.type === \"stream\"),\r\n    S.filter(\r\n      (wrapped): wrapped is Extract<Wrapped, { type: \"stream\" }> =>\r\n        wrapped.type === \"stream\"\r\n    ),\r\n    S.map((wrapped) => (wrapped as Extract<Wrapped, { type: \"stream\" }>).value)\r\n  );\r\n}\r\n\r\nexport function takeUntil<R2, E2>(until: T.Effect<R2, E2, any>) {\r\n  return function <R1, E1, A>(s: S.Stream<R1, E1, A>) {\r\n    return takeUntil_(s, until);\r\n  };\r\n}\r\n","export const tuple = <T extends any[]>(...ts: T) => ts;","import { effect as T, stream as S } from \"@matechs/effect\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { constant, flow, identity } from \"fp-ts/lib/function\";\r\nimport { subscribe, Emitter, EventFor } from \"../emitter\";\r\n\r\n/**\r\n * Document\r\n */\r\nexport const documentUri = '@uri/document'\r\n\r\nexport type DocumentEnv = { [documentUri]: Document }\r\n\r\nexport const getDocument = T.accessM(flow((_: DocumentEnv) => _[documentUri], T.pure))\r\n\r\nexport const mapDocument = <R, E, A>(f: (doc: Document) => T.Effect<R, E, A>) => pipe(\r\n  getDocument,\r\n  T.map(f)\r\n)\r\n\r\n/**\r\n * QuerySelector\r\n */\r\ninterface QuerySelector {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: TNode\r\n  ) => O.Option<HTMLElementTagNameMap[K]>;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: TNode\r\n  ) => O.Option<SVGElementTagNameMap[K]>;\r\n  <E extends Element = Element>(selectors: string): <TNode extends ParentNode>(\r\n    node: TNode\r\n  ) => O.Option<E>;\r\n}\r\n\r\ninterface QuerySelectorT {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<HTMLElementTagNameMap[K]>;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<SVGElementTagNameMap[K]>;\r\n  <E extends Element = Element>(selectors: string): <TNode extends ParentNode>(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<E>\r\n}\r\n\r\nexport const querySelector: QuerySelector = (selectors: string) => <\r\n  TNode extends ParentNode\r\n>(\r\n  el: TNode\r\n) => O.fromNullable(el.querySelector(selectors));\r\n\r\nexport const querySelectorO: QuerySelectorT = (selectors: string) => <\r\n  TNode extends ParentNode\r\n>(\r\n  nodeOT: O.Option<TNode>\r\n) =>\r\npipe(\r\n  nodeOT,\r\n  O.map((el) => querySelector(selectors)(el))\r\n)\r\n\r\n/**\r\n * $\r\n */\r\ninterface $ {\r\n    <K extends keyof HTMLElementTagNameMap>(selectors: K): T.Effect<DocumentEnv, never, O.Option<HTMLElementTagNameMap[K]>>;\r\n    <K extends keyof SVGElementTagNameMap>(selectors: K): T.Effect<DocumentEnv, never, O.Option<SVGElementTagNameMap[K]>>;\r\n    <E extends Element = Element>(selectors: string): T.Effect<DocumentEnv, never, O.Option<E>>;\r\n}\r\n\r\nexport const $: $ = (selectors: string) => pipe(\r\n  getDocument,\r\n  T.map(querySelector(selectors))\r\n)\r\n\r\n/**\r\n * ```hs\r\n * parentElement :: Node -> Option<HTMLelement>\r\n * ```\r\n */\r\nexport const parentElement = <TNode extends Node>(node: TNode) => O.fromNullable(node.parentElement)\r\n\r\n\r\nexport class EmptyOptionOfElement extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = \"EmptyOptionOfElement\";\r\n  }\r\n}\r\n\r\nexport const raiseEmptyOptionOfElement = (message: string) => T.raiseError(new EmptyOptionOfElement(message))\r\n\r\nexport const makeEventStream = <TEventType extends string>(eventType: TEventType) => <R, E, A extends Element>(elementT: T.Effect<R, E, O.Option<A>>) => pipe(\r\n  elementT,\r\n  T.map(elementO => pipe(\r\n    elementO,\r\n    O.map(subscribe(eventType)),\r\n    O.fold<S.Stream<Emitter, never, EventFor<TEventType>>, S.Stream<Emitter, EmptyOptionOfElement,  EventFor<TEventType>>>(\r\n      constant(S.raised(new EmptyOptionOfElement(`Option does not contain some element to create ${eventType} event stream for`))),\r\n      identity\r\n    )\r\n  ))\r\n)\r\n\r\nexport const makeClickStream = makeEventStream('click')","import { effect as T } from \"@matechs/effect\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport * as Rnd from \"fp-ts/lib/Random\";\r\nimport * as A from \"fp-ts/lib/Array\";\r\n\r\nimport { fromIO, rndColor } from \"../../utils/effect\";\r\nimport { tuple } from \"../../utils/tuple\";\r\n\r\nexport const uri = \"@uri/canvas\";\r\n\r\ninterface Flavoring<FlavorT> {\r\n  _type?: FlavorT;\r\n}\r\n\r\nexport type Flavor<T, FlavorT> = T & Flavoring<FlavorT>;\r\n\r\ntype Radian = Flavor<number, \"radius\">;\r\n\r\ntype Arc = {\r\n  type: \"@instruction/arc\";\r\n  args: [number, number, number, number, number, boolean];\r\n};\r\n\r\ntype ClearRect = {\r\n  type: \"@instruction/clearRect\";\r\n  args: [number, number, number, number];\r\n};\r\n\r\ntype LineTo = {\r\n  type: \"@instruction/lineTo\";\r\n  args: [number, number];\r\n};\r\n\r\ntype MoveTo = {\r\n  type: \"@instruction/moveTo\";\r\n  args: [number, number];\r\n};\r\n\r\ntype BeginPath = { type: \"@instruction/beginPath\" };\r\ntype ClosePath = { type: \"@instruction/closePath\" };\r\ntype Stroke = { type: \"@instruction/stroke\" };\r\ntype Fill = { type: \"@instruction/fill\" };\r\ntype Save = { type: \"@instruction/save\" };\r\ntype Restore = { type: \"@instruction/restore\" };\r\ntype LineWidth = { type: \"@instruction/lineWidth\"; args: [number] };\r\ntype StrokeStyle = { type: \"@instruction/strokeStyle\"; args: [string] };\r\ntype FillStyle = { type: \"@instruction/fillStyle\"; args: [string] };\r\n\r\nexport type InstructionGroup = { type: '@instruction-group', instructions: Instruction[] }\r\n\r\nexport type Instruction =\r\n  | Arc\r\n  | ClearRect\r\n  | BeginPath\r\n  | Stroke\r\n  | Fill\r\n  | LineWidth\r\n  | StrokeStyle\r\n  | FillStyle\r\n  | MoveTo\r\n  | ClosePath\r\n  | LineTo\r\n  | Save\r\n  | Restore\r\n  | InstructionGroup\r\n\r\nexport type Tagged<T> = { type: \"@tag\"; instructions: Instruction[]; data: T };\r\n\r\nexport const tag = (instructions: Instruction[]) => <T>(\r\n  data: T\r\n): Tagged<T> => ({ type: \"@tag\", instructions, data });\r\n\r\nexport const group = (instructions: Instruction[]): InstructionGroup => ({\r\n    type: '@instruction-group', instructions\r\n})\r\n\r\nexport interface Canvas {\r\n  [uri]: {\r\n    canvas: T.UIO<HTMLCanvasElement>;\r\n    clearRect: (\r\n      x?: number,\r\n      y?: number,\r\n      width?: number,\r\n      height?: number\r\n    ) => T.RUIO<Canvas, Instruction>;\r\n    arc: (\r\n      x: number,\r\n      y: number,\r\n      radius: number,\r\n      startAngle: Radian,\r\n      endAngle: Radian,\r\n      anticlockwise?: boolean | undefined\r\n    ) => T.UIO<Instruction>;\r\n    lineTo: (\r\n      x: number,\r\n      y: number,\r\n    ) => T.UIO<Instruction>;\r\n    moveTo: (\r\n      x: number,\r\n      y: number,\r\n    ) => T.UIO<Instruction>;\r\n    lineWidth: (width: number) => T.UIO<Instruction>;\r\n    beginPath: T.UIO<Instruction>;\r\n    closePath: T.UIO<Instruction>;\r\n    stroke: T.UIO<Instruction>;\r\n    save: T.UIO<Instruction>;\r\n    restore: T.UIO<Instruction>;\r\n    fill: T.UIO<Instruction>;\r\n    strokeStyle: (color: string) => T.UIO<Instruction>;\r\n    fillStyle: (color: string) => T.UIO<Instruction>;\r\n  };\r\n}\r\n\r\n/**\r\n * circle :: number -> number -> number -> number? -> number? -> Effect Canvas never (number, number, number)\r\n *\r\n * Draws a circle on the canvas. X, y, and radius are returned again.\r\n */\r\nexport const circle = (\r\n  x: number,\r\n  y: number,\r\n  r: number,\r\n  sa?: number,\r\n  ea?: number\r\n) =>\r\n  T.accessM((_: Canvas) => {\r\n    const ctx = _[uri];\r\n    return pipe(\r\n      T.zip(\r\n        sa ? T.pure(sa) : fromIO(Rnd.randomInt(0, 360)),\r\n        ea\r\n          ? T.pure(ea)\r\n          : fromIO(Rnd.randomInt((Math.PI / 10) * 1000, Math.PI * 1000))\r\n      ),\r\n      T.chain(([sa, ea]) => {\r\n        const list: T.UIO<Instruction>[] = [\r\n          pipe(rndColor(1), T.chain(ctx.strokeStyle)),\r\n          pipe(rndColor(), T.chain(ctx.fillStyle)),\r\n          ctx.lineWidth(2),\r\n          ctx.beginPath,\r\n          ctx.arc(x, y, r, sa, ea / 1000),\r\n          ctx.stroke,\r\n          ctx.fill,\r\n        ];\r\n\r\n        return A.array.sequence(T.effect)(list);\r\n      })\r\n    );\r\n  });\r\n\r\n/**\r\n * clear :: T.Effect Canvas never void\r\n *\r\n * Clears a canvas\r\n */\r\nexport const clear = T.accessM((_: Canvas) => _[uri].clearRect());\r\n\r\nconst accessCanvas = T.accessM((_: Canvas) => _[uri].canvas);\r\n\r\nconst accessCanvasProp = <TProp extends keyof HTMLCanvasElement>(prop: TProp) =>\r\n  pipe(\r\n    accessCanvas,\r\n    T.map((el) => el[prop])\r\n  );\r\n\r\nconst canvasPropIfNot = <TProp extends keyof HTMLCanvasElement>(\r\n  prop: TProp\r\n) => (value?: HTMLCanvasElement[TProp]) =>\r\n  value != null ? T.pure(value) : accessCanvasProp(prop);\r\n\r\nconst canvasWidthIfNot = canvasPropIfNot(\"width\");\r\nconst canvasHeightIfNot = canvasPropIfNot(\"height\");\r\n\r\nconst makeClearRectLive = (ctx: CanvasRenderingContext2D) => (\r\n  x?: number,\r\n  y?: number,\r\n  width?: number,\r\n  height?: number\r\n): T.Effect<Canvas, never, ClearRect> =>\r\n  Do(T.effect)\r\n    .bind(\"width\", canvasWidthIfNot(width))\r\n    .bind(\"height\", canvasHeightIfNot(height))\r\n    .doL(({ width, height }) =>\r\n      T.sync(() => ctx.clearRect(x || 0, y || 0, width, height))\r\n    )\r\n    .return(({ width, height }) => ({\r\n      type: \"@instruction/clearRect\",\r\n      args: tuple(x || 0, y || 0, width, height),\r\n    }));\r\n\r\nexport const isInstruction = <TInstructionType extends Instruction[\"type\"]>(\r\n  type: TInstructionType\r\n) => (\r\n  instruction: Instruction\r\n): instruction is Extract<Instruction, { type: TInstructionType }> =>\r\n  instruction.type === type;\r\n\r\nexport const parseInstruction = (instruction: Instruction) =>\r\n  T.accessM((_: Canvas): T.Effect<Canvas, never, Instruction> => {\r\n    const ctx = _[uri];\r\n\r\n    switch (instruction.type) {\r\n       case \"@instruction-group\": {\r\n        return pipe(\r\n            parseInstructions(instruction.instructions),\r\n            T.map(group)\r\n        )\r\n       }\r\n      case \"@instruction/arc\": {\r\n        return ctx.arc(...instruction.args);\r\n      }\r\n      case \"@instruction/lineTo\": {\r\n        return ctx.lineTo(...instruction.args);\r\n      }\r\n      case \"@instruction/moveTo\": {\r\n        return ctx.moveTo(...instruction.args);\r\n      }\r\n      case \"@instruction/save\": {\r\n        return ctx.save;\r\n      }\r\n      case \"@instruction/restore\": {\r\n        return ctx.restore;\r\n      }\r\n      case \"@instruction/beginPath\": {\r\n        return ctx.beginPath;\r\n      }\r\n      case \"@instruction/closePath\": {\r\n        return ctx.closePath;\r\n      }\r\n      case \"@instruction/clearRect\": {\r\n        return ctx.clearRect(...instruction.args);\r\n      }\r\n      case \"@instruction/fill\": {\r\n        return ctx.fill\r\n      }\r\n      case \"@instruction/fillStyle\": {\r\n        return ctx.fillStyle(...instruction.args);\r\n      }\r\n      case \"@instruction/lineWidth\": {\r\n        return ctx.lineWidth(...instruction.args);\r\n      }\r\n      case \"@instruction/stroke\": {\r\n        return ctx.stroke;\r\n      }\r\n      case \"@instruction/strokeStyle\": {\r\n        return ctx.strokeStyle(...instruction.args);\r\n      }\r\n    }\r\n  });\r\n\r\nexport const parseInstructions = (instructions: Instruction[]) => pipe(\r\n    instructions,\r\n    A.map(parseInstruction),\r\n    A.array.sequence(T.effect)\r\n)\r\n\r\nexport const makeCanvasLive = (ctx: CanvasRenderingContext2D): Canvas => {\r\n  return {\r\n    [uri]: {\r\n      canvas: T.pure(ctx.canvas),\r\n      arc: (\r\n        x: number,\r\n        y: number,\r\n        radius: number,\r\n        startAngle: Radian,\r\n        endAngle: Radian,\r\n        anticlockwise = false\r\n      ) =>\r\n        T.as(\r\n          T.sync(() =>\r\n            ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise)\r\n          ),\r\n          {\r\n            type: \"@instruction/arc\",\r\n            args: [x, y, radius, startAngle, endAngle, anticlockwise],\r\n          }\r\n        ),\r\n      lineTo: (\r\n        x: number,\r\n        y: number,\r\n      ) =>\r\n        T.as(\r\n          T.sync(() =>\r\n            ctx.lineTo(x, y)\r\n          ),\r\n          {\r\n            type: \"@instruction/lineTo\",\r\n            args: [x, y],\r\n          }\r\n        ),\r\n      moveTo: (\r\n        x: number,\r\n        y: number,\r\n      ) =>\r\n        T.as(\r\n          T.sync(() =>\r\n            ctx.moveTo(x, y)\r\n          ),\r\n          {\r\n            type: \"@instruction/moveTo\",\r\n            args: [x, y],\r\n          }\r\n        ),\r\n      clearRect: makeClearRectLive(ctx),\r\n      beginPath: T.as(\r\n        T.sync(() => ctx.beginPath()),\r\n        { type: \"@instruction/beginPath\" }\r\n      ),\r\n      closePath: T.as(\r\n        T.sync(() => ctx.closePath()),\r\n        { type: \"@instruction/closePath\" }\r\n      ),\r\n      stroke: T.as(\r\n        T.sync(() => ctx.stroke()),\r\n        { type: \"@instruction/stroke\" }\r\n      ),\r\n      save: T.as(\r\n        T.sync(() => ctx.save()),\r\n        { type: \"@instruction/save\" }\r\n      ),\r\n      restore: T.as(\r\n        T.sync(() => ctx.restore()),\r\n        { type: \"@instruction/restore\" }\r\n      ),\r\n      fill: T.as(\r\n        T.sync(() => ctx.fill()),\r\n        { type: \"@instruction/fill\" }\r\n      ),\r\n      lineWidth: (width: number) =>\r\n        T.as(\r\n          T.sync(() => {\r\n            ctx.lineWidth = Math.abs(width);\r\n          }),\r\n          { type: \"@instruction/lineWidth\", args: [width] }\r\n        ),\r\n      strokeStyle: (color: string) =>\r\n        T.as(\r\n          T.sync(() => {\r\n            ctx.strokeStyle = color;\r\n          }),\r\n          { type: \"@instruction/strokeStyle\", args: [color] }\r\n        ),\r\n      fillStyle: (color: string) =>\r\n        T.as(\r\n          T.sync(() => {\r\n            ctx.fillStyle = color;\r\n          }),\r\n          { type: \"@instruction/fillStyle\", args: [color] }\r\n        ),\r\n    },\r\n  };\r\n};\r\n\r\nexport const moveTo = ([x, y]: [number, number]) => T.accessM(\r\n    (_: Canvas) => _[uri].moveTo(x, y)\r\n)\r\n\r\nexport const lineTo = ([x, y]: [number, number]) => T.accessM(\r\n    (_: Canvas) => _[uri].lineTo(x, y)\r\n)\r\n\r\nexport const lineWidth = (width: number) => T.accessM(\r\n    (_: Canvas) => _[uri].lineWidth(width)\r\n)\r\n\r\nexport const beginPath = T.accessM(\r\n    (_: Canvas) => _[uri].beginPath\r\n)\r\n\r\nexport const closePath = T.accessM(\r\n    (_: Canvas) => _[uri].closePath\r\n)\r\n\r\nexport const stroke = T.accessM(\r\n    (_: Canvas) => _[uri].stroke\r\n)\r\n\r\nexport const accessContext = <R, E, A>(f: (ctx: Canvas[typeof uri]) => T.Effect<Canvas & R, E, A>) => T.accessM((_: Canvas) => f(_[uri]))","import { effect as T, stream as S, managed as M } from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { dot } from \"../../utils/getter\";\r\nimport { log } from \"@matechs/console\";\r\nimport { identity } from \"fp-ts/lib/function\";\r\n\r\nexport const uri = \"@uri/emitter\";\r\n\r\nexport type EventFor<TEventType extends string> = TEventType extends\r\n  | \"keypress\"\r\n  | \"keyup\"\r\n  | \"keydown\"\r\n  ? KeyboardEvent\r\n  : TEventType extends \"click\" | \"dblclick\" | \"mousemove\" | \"mousedown\" | \"mouseup\"\r\n  ? MouseEvent\r\n  : Event;\r\n\r\nexport type EventHandler<TEventType extends string> = (\r\n  evt: EventFor<TEventType>\r\n) => void;\r\n\r\nexport interface Emitter {\r\n  [uri]: {\r\n    fromEvent: <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<T.NoEnv, never, void>;\r\n    addEventListener: <TElement extends Element>(\r\n      el: TElement\r\n    ) => <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<T.NoEnv, never, void>;\r\n  };\r\n}\r\n\r\n// Events\r\nexport const subscribe = <TEventType extends string>(type: TEventType, ret?: any) => <\r\n  TElement extends Element\r\n>(\r\n  el?: TElement\r\n) => {\r\n  return S.fromSource(\r\n    M.managed.chain(\r\n      M.bracket(\r\n        T.accessM((_: Emitter) =>\r\n          T.sync(() => {\r\n            const { next, ops, hasCB } = S.su.queueUtils<\r\n              never,\r\n              EventFor<TEventType>\r\n            >();\r\n\r\n            const fn = el ? _[uri].addEventListener(el) : _[uri].fromEvent;\r\n\r\n            return {\r\n              unsubscribe: fn(type)(a => {\r\n                next({ _tag: \"offer\", a })\r\n                return ret\r\n              }),\r\n              ops,\r\n              hasCB\r\n            };\r\n          })\r\n        ),\r\n        dot(\"unsubscribe\")\r\n      ),\r\n      ({ ops, hasCB }) => S.su.emitter(ops, hasCB)\r\n    )\r\n  );\r\n};\r\n\r\nexport const makeEmitterLive = <\r\n  TRoot extends Pick<Element, \"addEventListener\" | \"removeEventListener\">\r\n>(\r\n  rootEl: TRoot\r\n): Emitter => {\r\n  return {\r\n    [uri]: {\r\n      fromEvent: <TEventType extends string>(type: TEventType) => (\r\n        cb: EventHandler<TEventType>\r\n      ) => {\r\n        const wrappedCb = (e: EventFor<TEventType>) => {\r\n          e.stopPropagation();\r\n          return cb(e);\r\n        };\r\n        rootEl.addEventListener(type, wrappedCb as any);\r\n\r\n        return T.sync(() => rootEl.removeEventListener(type, cb as any));\r\n      },\r\n      addEventListener: <TElement extends Element>(el: TElement) => <\r\n        TEventType extends string\r\n      >(\r\n        type: TEventType\r\n      ) => (cb: EventHandler<TEventType>) => {\r\n        const wrappedCb = (e: EventFor<TEventType>) => {\r\n          e.stopPropagation();\r\n          return cb(e);\r\n        };\r\n        el.addEventListener(type, wrappedCb as any);\r\n\r\n        return T.sync(() => el.removeEventListener(type, cb as any));\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * waitForKeyPress :: number -> Effect NoEnv never void\r\n *\r\n * Given a keyCode returns an effect that resolves once the user\r\n * presses a key on the keyboard matching the key code.\r\n */\r\nexport const waitForKeyPress = (...keyCodes: number[]) =>\r\n  T.effect.chain(log(\"Waiting for \", ...keyCodes), () =>\r\n    pipe(\r\n      subscribe(\"keyup\")(),\r\n      S.filter(event => keyCodes.includes(event.keyCode)),\r\n      S.take(1),\r\n      S.collectArray,\r\n      T.map(([evt]) => evt)\r\n    )\r\n  );\r\n","export const charCodeAt = (at: number) => (str: string) => str.charCodeAt(at)","import { effect as T, stream as S } from \"@matechs/effect\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport {\r\n  $,\r\n  makeClickStream,\r\n  raiseEmptyOptionOfElement\r\n} from \"../../modules/dom\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { constant, identity } from \"fp-ts/lib/function\";\r\n\r\nexport default (selector: string) => {\r\n  const element = $<HTMLButtonElement>(selector);\r\n\r\n  const clicks = pipe(\r\n    element,\r\n    makeClickStream,\r\n    S.encaseEffect,\r\n    S.chain(identity)\r\n  );\r\n\r\n  const withButton = (error: string) => <A>(\r\n    cb: (btn: HTMLButtonElement) => A\r\n  ) =>\r\n    pipe(\r\n      element,\r\n      T.chain(elementO =>\r\n        pipe(\r\n          elementO,\r\n          O.fold(constant(raiseEmptyOptionOfElement(error)), btn =>\r\n            T.sync(() => cb(btn))\r\n          )\r\n        )\r\n      )\r\n    );\r\n\r\n  const disable = withButton(`Unable to disable button(${selector})`)(btn =>\r\n    btn.setAttribute(\"disabled\", \"true\")\r\n  );\r\n\r\n  const enable = withButton(`Unable to enable button(${selector})`)(btn =>\r\n    btn.removeAttribute(\"disabled\")\r\n  );\r\n\r\n  return { element, clicks, disable, enable };\r\n};\r\n","import make from \"./make\";\r\n\r\nexport const {\r\n    element,\r\n    clicks,\r\n    disable,\r\n    enable,\r\n} = make(\"#btn-add-polygon\")\r\n","import make from \"./make\";\r\n\r\nexport const {\r\n    element,\r\n    clicks,\r\n    disable,\r\n    enable,\r\n} = make(\"#btn-add-circles\")\r\n","import make from \"./make\";\r\n\r\nexport const {\r\n    element,\r\n    clicks,\r\n    disable,\r\n    enable,\r\n} = make(\"#btn-add-markers\")\r\n","import make from \"./make\";\r\n\r\nexport const {\r\n    element,\r\n    clicks,\r\n    disable,\r\n    enable,\r\n} = make(\"#btn-save\")\r\n","import make from \"./make\";\r\n\r\nexport const {\r\n    element,\r\n    clicks,\r\n    disable,\r\n    enable,\r\n} = make(\"#btn-cancel\")\r\n","import make from \"./make\";\r\n\r\nexport const {\r\n    element,\r\n    clicks,\r\n    disable,\r\n    enable,\r\n} = make(\"#btn-clear\")\r\n","import { effect as T, stream as S, ref } from \"@matechs/effect\";\r\nimport * as Rnd from \"fp-ts/lib/Random\";\r\nimport * as A from \"fp-ts/lib/Array\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\n\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { flow, identity, constant, constVoid } from \"fp-ts/lib/function\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\nimport { dot } from \"../../utils/getter\";\r\n\r\nimport * as Canvas from \"../../modules/canvas\";\r\nimport * as Emitter from \"../../modules/emitter\";\r\nimport { fromIO, takeUntil, rndColor } from \"../../utils/effect\";\r\nimport { tuple } from \"../../utils/tuple\";\r\nimport { charCodeAt } from \"../../utils/string\";\r\nimport { log, Console } from \"@matechs/console\";\r\n\r\n// Components\r\nimport * as addPolygonBtn from \"../../components/buttons/add-polygon\";\r\nimport * as addCircleBtn from \"../../components/buttons/add-circles\";\r\nimport * as addMarkersBtn from \"../../components/buttons/add-markers\";\r\nimport * as saveBtn from \"../../components/buttons/save\";\r\nimport * as cancelBtn from \"../../components/buttons/cancel\";\r\nimport * as clearBtn from \"../../components/buttons/clear\";\r\n\r\nimport {\r\n  $,\r\n  raiseEmptyOptionOfElement,\r\n  EmptyOptionOfElement\r\n} from \"../../modules/dom\";\r\n\r\ntype X = number;\r\ntype Y = number;\r\ntype Radius = number;\r\ntype Angle = number;\r\ntype StartAngle = Angle;\r\ntype EndAngle = Angle;\r\ntype TimeStamp = number;\r\n\r\ntype Circle = [X, Y, Radius, StartAngle, EndAngle];\r\ntype TimeStamped = [X, Y, Radius, StartAngle, EndAngle, TimeStamp];\r\n\r\n/**\r\n * ```hs\r\n * randomCircle :: (number, number) -> Stream Canvas never Circle\r\n * ```\r\n *\r\n * Draws a circle with a random radius\r\n */\r\nconst randomCircle = ([x, y]: [X, Y]) =>\r\n  pipe(\r\n    // Get a random radius for the circle to draw\r\n    Rnd.randomInt(30, 200),\r\n    // Convert IO to Effect\r\n    fromIO,\r\n    // Map effect that produces a random int to an effect that draws a circle\r\n    T.chain(r => Canvas.circle(x, y, r)),\r\n    T.map(instructions => Canvas.group(instructions))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n * mapMouseEventToCoord :: MouseEvent -> (X, Y\r\n * ```\r\n */\r\nconst mapMouseEventToCoord = (e: MouseEvent) => tuple(e.offsetX, e.offsetY);\r\n\r\nconst makeOnClick = <R, E, A>(\r\n  makeEffect: ([x, y]: [X, Y]) => T.Effect<R, E, A>\r\n) =>\r\n  pipe(\r\n    // Read canvas element from environment\r\n    T.accessM((_: Canvas.Canvas) => _[Canvas.uri].canvas),\r\n    // Turn it into a stream\r\n    S.encaseEffect,\r\n    // Flat map the 1 element stream containing the canvas element to a stream of mouse clicks\r\n    S.chain(Emitter.subscribe(\"click\")),\r\n    //   // Take mouse clicks until the user presses d or D\r\n    //   takeUntil(Emitter.waitForKeyPress(68)),\r\n    // Map the mouse event to it's coordinates\r\n    S.map(mapMouseEventToCoord),\r\n    // Flat map the stream of coordinates to\r\n    // a stream that draws a circle\r\n    S.chain(flow(makeEffect, S.encaseEffect))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n * drawCirclesOnClick :: Effect (Console & Canvas & Emitter) never [TimeStamped]\r\n * ```\r\n *\r\n * Draw a circle on every mouseclick until the program is terminated by pressing 'd' or 'D'\r\n */\r\nconst drawCirclesOnClick = makeOnClick(randomCircle);\r\n\r\n/**\r\n * Draw a marker\r\n */\r\nconst marker = ([x, y]: [number, number]) =>\r\n  Canvas.accessContext(ctx =>\r\n    pipe(\r\n      [\r\n        ctx.beginPath,\r\n        ctx.arc(x, y, 3, 0, Math.PI * 2),\r\n        ctx.strokeStyle(\"#000000\"),\r\n        ctx.fillStyle(\"#ffffff\"),\r\n        ctx.lineWidth(2),\r\n        ctx.stroke,\r\n        ctx.fill\r\n      ],\r\n      A.array.sequence(T.effect),\r\n      T.map(Canvas.group)\r\n    )\r\n  );\r\n\r\nconst drawMarkerOnClick = makeOnClick(marker);\r\n\r\n/**\r\n * Take one element from a stream and return it as an effect.\r\n */\r\nconst takeOne = <R, E, A>(stream: S.Stream<R, E, A>) =>\r\n  pipe(\r\n    stream,\r\n    S.take(1),\r\n    S.collectArray,\r\n    T.map(([a]) => a)\r\n  );\r\n\r\nconst polygonCoordinates2Effect = (colour = rndColor()) => ([h, ...t]: [\r\n  number,\r\n  number\r\n][]) =>\r\n  pipe(\r\n    colour,\r\n    T.chain(colour =>\r\n      A.array.sequence(T.effect)(\r\n        pipe([\r\n          Canvas.beginPath,\r\n          Canvas.lineWidth(1),\r\n          Canvas.accessContext(ctx => ctx.strokeStyle(\"#000\")),\r\n          Canvas.accessContext(ctx => ctx.fillStyle(colour)),\r\n          // Move the cursor the head of the set of coordinates.\r\n          Canvas.moveTo(h),\r\n          // From there draw a line to every next coordinate\r\n          ...t.map(Canvas.lineTo),\r\n          Canvas.closePath,\r\n          Canvas.stroke,\r\n          Canvas.accessContext(ctx => ctx.fill),\r\n          // Draw a marker for the head position\r\n          marker(h),\r\n          // And every other.\r\n          ...t.map(marker)\r\n        ])\r\n      )\r\n    ),\r\n    T.map(Canvas.group)\r\n  );\r\n\r\ntype RestoreCanvas = { restoreCanvas: T.Effect<Canvas.Canvas, never, void> };\r\n\r\nconst restoreCanvas = T.accessM((_: RestoreCanvas) => _.restoreCanvas);\r\n\r\n/**\r\n * Let the user draw a polygon.\r\n * @param onState The current state of the canvas. This is needed to redraw it on every mouse move.\r\n */\r\nconst drawPolygon = pipe(\r\n  // Create a ref to store the coordinates of the new polygon in.\r\n\r\n  ref.makeRef({\r\n    coords: [] as [number, number][],\r\n    instructionGroup: O.none as O.Option<Canvas.InstructionGroup>\r\n  }),\r\n  S.encaseEffect,\r\n  S.chain(polygonRef =>\r\n    //   T.zip(\r\n    pipe(\r\n      $(\"canvas\"),\r\n      // Wait for the user to assign the first coordinate by clicking on the canvas.\r\n      T.chain(canvasO =>\r\n        pipe(\r\n          canvasO,\r\n          O.fold<\r\n            HTMLCanvasElement,\r\n            T.Effect<\r\n              Console & Emitter.Emitter,\r\n              EmptyOptionOfElement,\r\n              MouseEvent\r\n            >\r\n          >(\r\n            constant(raiseEmptyOptionOfElement(\"Canvas not available\")),\r\n            flow(Emitter.subscribe(\"click\"), takeOne)\r\n          )\r\n        )\r\n      ),\r\n      // T.chain(() => takeOne(Emitter.subscribe(\"click\"))),\r\n      T.map(mapMouseEventToCoord),\r\n      // Store the first coordinate using the reference\r\n      T.chain(coord =>\r\n        polygonRef.set({ coords: [coord], instructionGroup: O.none })\r\n      ),\r\n      // Continue as a stream\r\n      S.encaseEffect,\r\n      S.chain(\r\n        constant(\r\n          pipe(\r\n            // Race between mousemove and click\r\n            pipe(\r\n              $(\"canvas\"),\r\n              // Wait for the user to assign the first coordinate by clicking on the canvas.\r\n              T.chain(canvasO =>\r\n                pipe(\r\n                  canvasO,\r\n                  O.fold<\r\n                    HTMLCanvasElement,\r\n                    T.Effect<\r\n                      Console & Emitter.Emitter,\r\n                      EmptyOptionOfElement,\r\n                      MouseEvent\r\n                    >\r\n                  >(\r\n                    constant(raiseEmptyOptionOfElement(\"Canvas not available\")),\r\n                    canvas =>\r\n                      T.race(\r\n                        takeOne(Emitter.subscribe(\"click\")(canvas)),\r\n                        takeOne(Emitter.subscribe(\"mousemove\")(canvas))\r\n                      )\r\n                  )\r\n                )\r\n              )\r\n            ),\r\n            // Chain mousevent to drawing the polygon\r\n            T.chain(event =>\r\n              pipe(\r\n                event,\r\n                mapMouseEventToCoord,\r\n                coord =>\r\n                  event.type === \"click\"\r\n                    ? // If click won the race, update the reference with the new coordinate\r\n                      pipe(\r\n                        polygonRef.update(({ coords, instructionGroup }) => ({\r\n                          coords: [...coords, coord],\r\n                          instructionGroup\r\n                        })),\r\n                        // Retain the set of coordinates from the update\r\n                        T.map(dot(\"coords\"))\r\n                      )\r\n                    : // If mousemove won the race, get the coordiantes from the reference\r\n                      // and concat the \"move\" coordinate.\r\n                      pipe(\r\n                        polygonRef.get,\r\n                        T.map(({ coords }) => [...coords, coord])\r\n                      ),\r\n                // Retain the coordinates to be drawn with the event type\r\n                T.map(coords => tuple(event.type, coords))\r\n              )\r\n            ),\r\n            T.chain(([eventType, coords]) =>\r\n              Do(T.effect)\r\n                // Clear the canvas\r\n                .do(Canvas.clear)\r\n                // Restore what was already previously drawn\r\n                .do(restoreCanvas)\r\n                // Draw the polygon and stream the instructions\r\n                .bind(\r\n                  \"polygonInstructions\",\r\n                  polygonCoordinates2Effect(\r\n                    eventType === \"click\" ? rndColor() : T.pure(\"#ccc\")\r\n                  )(coords)\r\n                )\r\n                // Update the reference to the instructions\r\n                .doL(({ polygonInstructions }) =>\r\n                  eventType === \"click\" && coords.length > 2\r\n                    ? polygonRef.update(({ coords, instructionGroup }) => ({\r\n                        coords,\r\n                        instructionGroup: O.some(polygonInstructions)\r\n                      }))\r\n                    : T.pure(1)\r\n                )\r\n                .done()\r\n            ),\r\n            S.encaseEffect,\r\n            // Rinse and repeat the race\r\n            S.chain(\r\n              constant(\r\n                pipe(\r\n                  polygonRef.get,\r\n                  T.map(dot(\"instructionGroup\")),\r\n                  S.encaseEffect\r\n                )\r\n              )\r\n            ),\r\n            S.repeat\r\n          )\r\n        )\r\n      )\r\n    )\r\n  )\r\n);\r\n\r\nconst makeWaitForMenuChoice = (menuCodes: number[]) =>\r\n  pipe(\r\n    Emitter.subscribe(\"keyup\")(),\r\n    S.map(dot(\"keyCode\")),\r\n    S.filter(menuCodes.includes.bind(menuCodes)),\r\n    S.take(1),\r\n    S.collectArray,\r\n    T.map(([keyCode]) => keyCode),\r\n    T.map(String.fromCharCode)\r\n  );\r\n\r\nconst waitForAddPolygonButtonClick = pipe(\r\n  takeOne(addPolygonBtn.clicks),\r\n  T.map(_ => \"3\")\r\n);\r\n\r\nconst waitForCirclesButtonClick = pipe(\r\n  takeOne(addCircleBtn.clicks),\r\n  T.map(_ => \"1\")\r\n);\r\n\r\nconst waitForAddMarkersButtonClick = pipe(\r\n  takeOne(addMarkersBtn.clicks),\r\n  T.map(_ => \"2\")\r\n);\r\n\r\nconst waitForSaveButtonClick = pipe(\r\n  takeOne(saveBtn.clicks),\r\n  T.map(_ => \"S\")\r\n);\r\nconst waitForAddCancelButtonClick = pipe(\r\n  takeOne(cancelBtn.clicks),\r\n  T.map(_ => \"X\")\r\n);\r\n\r\nconst waitForClearButtonClick = pipe(\r\n  takeOne(clearBtn.clicks),\r\n  T.map(_ => \"X\")\r\n);\r\n\r\nconst waitForMainMenuChoice = pipe(\r\n  T.race(\r\n    pipe(\r\n      [\"1\", \"2\", \"3\", \"R\", \"X\"],\r\n      A.map(charCodeAt(0)),\r\n      makeWaitForMenuChoice\r\n    ),\r\n    T.race(\r\n      T.race(waitForAddPolygonButtonClick, waitForCirclesButtonClick),\r\n      T.race(waitForAddMarkersButtonClick, waitForClearButtonClick)\r\n    )\r\n  ),\r\n  T.chain(choice =>\r\n    T.as(\r\n      A.array.sequence(T.effect)(\r\n        choice !== \"X\"\r\n          ? [\r\n              addMarkersBtn.disable,\r\n              addPolygonBtn.disable,\r\n              addCircleBtn.disable,\r\n              saveBtn.enable,\r\n              cancelBtn.enable\r\n            ]\r\n          : []\r\n      ),\r\n      choice\r\n    )\r\n  )\r\n  // T.chain(key => T.as(log(\"key\", key), key))\r\n);\r\n\r\n//S.Stream<DocumentEnv & Emitter, string, MouseEvent>\r\n\r\nconst waitForToolMenuChoice = pipe(\r\n  [\"S\", \"X\"],\r\n  A.map(charCodeAt(0)),\r\n  makeWaitForMenuChoice,\r\n  effect =>\r\n    T.race(effect, T.race(waitForSaveButtonClick, waitForAddCancelButtonClick)),\r\n  T.chain(choice =>\r\n    T.as(\r\n      A.array.sequence(T.effect)([\r\n        addMarkersBtn.enable,\r\n        addPolygonBtn.enable,\r\n        addCircleBtn.enable,\r\n        saveBtn.disable,\r\n        cancelBtn.disable\r\n      ]),\r\n      choice\r\n    )\r\n  )\r\n);\r\n\r\nconst makeDoUntilMenuChoice = <R, E, A>(effect: S.Stream<R, E, A>) =>\r\n  pipe(\r\n    // Run 2 effects in parallell\r\n    T.parZip(\r\n      // One that runs the effect until a menu choice (S or X) is pressed\r\n      pipe(effect, takeUntil(waitForToolMenuChoice), S.collectArray),\r\n      // And second the menu choice itself\r\n      waitForToolMenuChoice\r\n    ),\r\n    // If the menu choice was X return an empty list of instructions otherwise return instructions.\r\n    T.map(([instructions, code]) =>\r\n      code === \"S\" ? O.some(instructions) : O.none\r\n    )\r\n  );\r\n\r\ntype EffectOf<T> = T extends T.Effect<any, any, infer A> ? A : never;\r\n\r\nconst foo = makeDoUntilMenuChoice(drawCirclesOnClick);\r\n/**\r\n * Main program\r\n */\r\nexport const main = Do(T.effect)\r\n  // Create a ref that stores canvas drawings as serializable instructions.\r\n  .bind(\r\n    \"stateRef\",\r\n    pipe(\r\n      A.array.sequence(T.effect)([\r\n        saveBtn.disable,\r\n        cancelBtn.disable,\r\n        clearBtn.disable\r\n      ]),\r\n      T.chain(\r\n        constant(\r\n          ref.makeRef({\r\n            instructions: [] as Canvas.Instruction[]\r\n          })\r\n        )\r\n      )\r\n    )\r\n  )\r\n  .bindL(\"restoreCanvas\", ({ stateRef }) =>\r\n    T.sync(() =>\r\n      pipe(\r\n        stateRef.get,\r\n        T.chain(state =>\r\n          pipe(\r\n            state,\r\n            dot(\"instructions\"),\r\n            A.map(Canvas.parseInstruction),\r\n            A.array.sequence(T.effect)\r\n          )\r\n        ),\r\n        T.map(constVoid)\r\n      )\r\n    )\r\n  )\r\n  .doL(({ stateRef, restoreCanvas }) =>\r\n    // Use the ref in a program that runs forever.,\r\n    T.forever(\r\n      Do(T.effect)\r\n        // Clear the canvas on every run.\r\n        .do(Canvas.clear)\r\n        // Convert the instructions in state to effects that draw onto the canvas.\r\n        .do(\r\n          pipe(\r\n            stateRef.get,\r\n            T.map(flow(dot(\"instructions\"), dot(\"length\"), Boolean)),\r\n            T.chain(hasInstructions =>\r\n              hasInstructions ? clearBtn.enable : clearBtn.disable\r\n            )\r\n          )\r\n        )\r\n        .do(\r\n          pipe(\r\n            stateRef.get,\r\n            T.chain(state => Canvas.parseInstructions(state.instructions))\r\n          )\r\n        )\r\n        // Wait for the user to make a choice (1, 2, or X)\r\n        .bind(\"mainMenuChoice\", waitForMainMenuChoice)\r\n        // Allow the user to draw on canvas or clear it if the choice was X\r\n        .bindL(\"additionalInstructions\", ({ mainMenuChoice }) => {\r\n          switch (mainMenuChoice) {\r\n            case \"1\": {\r\n              return foo;\r\n            }\r\n            case \"2\": {\r\n              const program = makeDoUntilMenuChoice(drawMarkerOnClick);\r\n              return program;\r\n            }\r\n            case \"3\": {\r\n              const program = pipe(\r\n                // Let the user draw a polygon until they press S or X (to cancel)\r\n                makeDoUntilMenuChoice(\r\n                  pipe(\r\n                    stateRef.get,\r\n                    T.map(dot(\"instructions\")),\r\n                    S.encaseEffect,\r\n                    S.chain(constant(drawPolygon))\r\n                  )\r\n                ),\r\n                // makeDoUntilMenuChoice returns an option to indicate cancellation\r\n                T.map(option =>\r\n                  pipe(\r\n                    option,\r\n                    // drawPolygon also returns an option and is a stream (array) of options\r\n                    O.chain(suboptions =>\r\n                      pipe(\r\n                        suboptions,\r\n                        // We only want the last polygon since that was the final version\r\n                        A.reverse,\r\n                        ([h]) => h\r\n                      )\r\n                    ),\r\n                    // Put it back into an array (the other 2 programs emit arrays)\r\n                    O.map(A.of)\r\n                  )\r\n                ),\r\n                T.provideS({ restoreCanvas })\r\n              );\r\n\r\n              return program;\r\n            }\r\n            case \"X\": {\r\n              // Empty the instructions in state\r\n              return T.as(\r\n                stateRef.update(() => ({ instructions: [] })),\r\n                O.none as O.Option<Canvas.InstructionGroup[]>\r\n              );\r\n            }\r\n            default:\r\n              return T.pure(O.none as O.Option<Canvas.InstructionGroup[]>);\r\n          }\r\n        })\r\n        // Update state and add the new set of instructions to the current set\r\n        .doL(({ additionalInstructions }) =>\r\n          pipe(\r\n            additionalInstructions,\r\n            O.map(instructions =>\r\n              T.as(\r\n                stateRef.update(current => {\r\n                  return {\r\n                    instructions: [...current.instructions, ...instructions]\r\n                  };\r\n                }),\r\n                1\r\n              )\r\n            ),\r\n            O.fold(constant(T.pure(1)), identity)\r\n          )\r\n        )\r\n        .done()\r\n    )\r\n  )\r\n  .done();\r\n","import \"./index.scss\";\nimport \"./App.scss\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nimport * as Circles from \"./apps/circles\";\nimport { parentElement, mapDocument, documentUri, $ } from \"./modules/dom\";\nimport { pipe } from \"fp-ts/lib/pipeable\";\n\nimport { effect as T, stream as S } from \"@matechs/effect\";\nimport * as O from \"fp-ts/lib/Option\";\nimport { constVoid, flow, identity, constant } from \"fp-ts/lib/function\";\nimport { snd } from \"fp-ts/lib/ReadonlyTuple\";\nimport { makeEmitterLive, subscribe } from \"./modules/emitter\";\nimport { makeCanvasLive } from \"./modules/canvas\";\nimport { provideConsole } from \"@matechs/console\";\n\nconst voidEffect = flow(constVoid, T.pure);\n\nconst program = mapDocument(doc =>\n  pipe(\n    $(\"canvas\"),\n    T.chain(canvasO =>\n      pipe(\n        canvasO,\n        O.fold(voidEffect, canvas =>\n          pipe(\n            canvas,\n            parentElement,\n            O.fold(voidEffect, parent =>\n              pipe(\n                T.zip(\n                  pipe(\n                    T.sync(() => {\n                      const { width, height } = parent.getBoundingClientRect();\n                      canvas.width = width;\n                      canvas.height = height;\n\n                      // Dirty but seems to be the only solution to\n                      // preventing text selection from happening when\n                      // clicking fast on the canvas.\n                      // Using addEventListener doesn't work\n                      // See https://stackoverflow.com/questions/3799686/clicking-inside-canvas-element-selects-text\n                      canvas.onmousedown = constant(false)\n                      return canvas\n                    }),\n                    // T.map(subscribe('mousedown', false)),\n                    // T.map(S.drain),\n                    // T.map(T.fork),\n                    // T.chain(identity),\n                    T.chain(_ => Circles.main),\n                    T.provideS(makeEmitterLive(doc)),\n                    T.provideS(makeCanvasLive(canvas.getContext(\"2d\")!))\n                  ),\n                  voidEffect()\n                ),\n                T.map(snd)\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n);\n\npipe(\n  pipe(program, T.chain(identity)),\n  T.provideS({ [documentUri]: document }),\n  provideConsole,\n  T.run,\n);\n\n// ReactDOM.render(\n//   <React.StrictMode>\n//     <App />\n//   </React.StrictMode>,\n//   document.getElementById(\"root\")\n// );\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}